#!/usr/bin/env python3
import binascii, json, sys
from jsonrpc import JSONRPCResponseManager, Dispatcher
from btchip.btchip import *
from btchip.btchipUtils import *

def signrawtransaction(hexstring, prevtxs, privkeys):
    dongle = getDongle(True)
    app = btchip(dongle)

    spend_tx = transaction = binascii.unhexlify(hexstring)
    hdKeypaths = json.loads(privkeys)
    publickeys = []
    for path in hdKeypaths:
        # TODO make sure path compatible
        publickeys.append(compress_public_key(app.getWalletPublicKey(path)['publicKey']))

    prevtxarr = []
    prevoutScriptPubkeyarr = []
    trustedInput = []
    for prevtx in json.loads(prevtxs):
        # Get the trusted input associated to the UTXO
        prevtxarr.append(bitcoinTransaction(prevtx["transaction"]))
        # scriptpubkey of the prevout
        prevoutScriptPubkeyarr.append(prevtxarr[-1][prevtx["vout"]].script)
        # consumes input
        trustedInput.append(app.getTrustedInput(prevtxarr[-1], prevtx["vout"]))

    # TODO get change_path

    outputData = []
    signatures = []
    inputScripts = []
    first = True
    for trinput, index in enumerate(trustedInput):
        app.startUntrustedTransaction(first, index, trustedInput, prevoutScriptPubkeyarr[index])
        first = False
        # Finalize and sign
        outputData.append(app.finalizeInput("DUMMY", -1, -1, change_path, spend_tx))
        signatures.append(app.untrustedHashSign(hdKeyPaths[index]))
        inputScripts.append(get_regular_input_script(signature, publicKey))




    # Put tx back together
    transaction = format_transaction(outputData['outputData'], [ [ trustedInput['value'], inputScript] ])
    #print "Generated transaction : " + str(transaction).encode('hex')
    return { "hex": str(transaction).encode('hex') }

dispatcher = Dispatcher({
    "signrawtransaction": signrawtransaction,
})

request = sys.stdin.read()
response = JSONRPCResponseManager.handle(request, dispatcher)
print(response.json)

